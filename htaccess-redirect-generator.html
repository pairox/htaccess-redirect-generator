<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mass Apache .htaccess redirect generator — Local Copy</title>
  <style>
    body{font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:18px;background:#f7f8fb;color:#111}
    h1{font-size:20px}
    textarea{width:100%;min-height:160px;font-family:monospace;padding:8px;border-radius:6px}
    .row{display:flex;gap:12px;margin-bottom:12px}
    .col{flex:1}
    label{display:block;margin-bottom:6px;font-size:13px}
    .opts{display:flex;gap:8px;flex-wrap:wrap}
    button{padding:8px 12px;border-radius:8px;border:0;background:#2563eb;color:#fff;cursor:pointer}
    .small{font-size:12px;color:#444}
    .warn{color:#b45309}
    pre{background:#fff;border-radius:6px;padding:12px;overflow:auto}
  </style>
</head>
<body>
  <h1>Mass Apache .htaccess redirect generator — локальная копия</h1>
  <p class="small">Вставьте список правил в формате <code>from_url;to_url</code> — по одному правилу на строку. Поддерживаются: разделитель «;», таб, «,». Опции внизу. Генератор выпускает готовый код для вставки в <code>.htaccess</code>.</p>

  <div class="row">
    <div class="col">
      <label>Вход (old_url;new_url)</label>
      <textarea id="input" placeholder="/old; /new
http://example.com/old/page.html; https://example.com/new/">
</textarea>
    </div>
    <div class="col">
      <label>Выход (.htaccess)</label>
      <textarea id="output" readonly placeholder="Сгенерированный .htaccess появится здесь"></textarea>
    </div>
  </div>

  <div style="margin-bottom:12px">
    <div class="opts">
      <label><input type="checkbox" id="stripFromDomain"> Убирать домен в FROM (оставлять относительный путь)</label>
      <label><input type="checkbox" id="stripToDomain"> Убирать домен в TO (оставлять относительный путь)</label>
      <label><input type="checkbox" id="decode"> Декодировать входные URL (urldecode)</label>
      <label><input type="checkbox" id="nc" checked> Case-insensitive (NC)</label>
      <label><input type="radio" name="qs" id="qsd" checked> Сбрасывать query (QSD)</label>
      <label><input type="radio" name="qs" id="qsa"> Добавлять query к TO (QSA)</label>
      <label><input type="checkbox" id="leadingSlash"> Добвать ^/? в начале паттерна (совместимость серверов)</label>
    </div>
  </div>

  <div style="margin-bottom:12px">
    <button id="generate">Сгенерировать</button>
    <button id="copyOut">Копировать в буфер</button>
    <span id="info" class="small"></span>
  </div>

  <h3>Примечания</h3>
  <ul>
    <li class="small">Если в FROM присутствуют параметры (пример: <code>/index.php?product=123&amp;color=blue</code>), генератор создаст для каждого параметра <code>RewriteCond %{QUERY_STRING}</code> и правило будет выполняться только при совпадении указанных параметров.</li>
    <li class="small">При использовании QSD в конце целевого URL автоматически добавляется знак <code>?</code>, чтобы убедиться, что Apache не передаст старый query (QSD делает то же самое, но знак <code>?</code> даёт дополнительную страховку на старых версиях Apache).</li>
  </ul>

  <script>
    function urldecode(s){ try{ return decodeURIComponent(s.replace(/\+/g,' ')); }catch(e){return s} }
    function escapeForRegex(s){ // escape regex but keep leading ^ and $ if present
      return s.replace(/[-\\\/\^$*+?.()|[\]{}]/g, function(m){ return '\\'+m; });
    }

    function parseLine(line, delimiter){
      // split by delimiter variants ; or tab or comma if not found
      let parts;
      if(line.indexOf(';')!==-1) parts=line.split(';');
      else if(line.indexOf('\t')!==-1) parts=line.split('\t');
      else if(line.indexOf(',')!==-1) parts=line.split(',');
      else parts=line.split(';');
      if(parts.length<2) return null;
      return [parts[0].trim(), parts.slice(1).join(delimiter||';').trim()];
    }

    function stripDomain(url){
      // remove scheme and host, keep path+query
      return url.replace(/^[a-zA-Z]+:\/\/[0-9a-zA-Z\.\-:@]+/,'');
    }

    document.getElementById('generate').addEventListener('click', ()=>{
      const raw = document.getElementById('input').value.split('\n');
      const out = [];
      const seen = new Map();
      const opts = {
        stripFrom: document.getElementById('stripFromDomain').checked,
        stripTo: document.getElementById('stripToDomain').checked,
        decode: document.getElementById('decode').checked,
        nc: document.getElementById('nc').checked,
        qsd: document.getElementById('qsd').checked,
        qsa: document.getElementById('qsa').checked,
        leadingSlash: document.getElementById('leadingSlash').checked
      };

      out.push('# Generated by local htaccess redirect generator');
      out.push('RewriteEngine On');
      out.push('');

      let warnings = [];

      raw.forEach((rawline, idx)=>{
        const line = rawline.trim();
        if(!line) return;
        const parts = parseLine(line);
        if(!parts){ warnings.push('Строка '+(idx+1)+' не распознана (ожидается "from;to").'); return; }
        let [from,to] = parts;
        if(opts.decode){ from = urldecode(from); to = urldecode(to); }
        if(opts.stripFrom) from = stripDomain(from);
        if(opts.stripTo) to = stripDomain(to);

        // normalize from: remove leading slash for pattern, but remember it
        // separate path and query
        let fromPath = from;
        let query = '';
        if(fromPath.indexOf('?')!==-1){ [fromPath, query] = fromPath.split('?'); }
        fromPath = fromPath.replace(/^\/+/, ''); // pattern expects no leading slash because htaccess is per-directory
        if(fromPath==='') fromPath='';

        // duplicate detection by canonical fromPath + query
        const key = fromPath + '??' + query;
        if(seen.has(key)){ warnings.push('Дубликат FROM (строка '+(idx+1)+') -> '+from); return; }
        seen.set(key, true);

        // build conditions for query params
        const conds = [];
        if(query){
          const params = query.split('&').filter(Boolean);
          params.forEach(p=>{
            const [k,v] = p.split('=');
            const esck = k.replace(/[-\\/\^$*+?.()|[\]{}]/g,'\\$&');
            const escv = (v||'').replace(/[-\\/\^$*+?.()|[\]{}]/g,'\\$&');
            if(k && v!==undefined){
              conds.push("RewriteCond %{QUERY_STRING} (?:^|&)"+esck+"="+escv+"(?:&|$)");
            }else if(k){
              conds.push("RewriteCond %{QUERY_STRING} (?:^|&)"+esck+"(?:&|$)");
            }
          });
        }

        // prepare pattern
        let pattern = fromPath || '$';
        pattern = escapeForRegex(pattern);
        if(opts.leadingSlash) pattern = '/?' + pattern;
        // ensure ^...$
        if(!pattern.startsWith('^')) pattern = '^' + pattern;
        if(!pattern.endsWith('$')) pattern = pattern + '$';

        // prepare flags
        const flags = [];
        flags.push('R=301');
        flags.push('L');
        if(opts.nc) flags.push('NC');
        if(opts.qsd) flags.push('QSD');
        if(opts.qsa) flags.push('QSA');

        // prepare target: if qsd then add ? to prevent appending original query on older servers
        let target = to;
        if(opts.stripTo){ /* already stripped */ }
        if(opts.qsd){ if(!target.endsWith('?')) target = target + '?'; }

        // output conds then rule
        conds.forEach(c=> out.push(c));
        out.push('RewriteRule ' + pattern + ' ' + target + ' [' + flags.join(',') + ']');
        out.push('');
      });

      if(warnings.length) out.unshift('# WARNINGS:\n# '+warnings.join('\n# '));
      document.getElementById('output').value = out.join('\n');
      document.getElementById('info').textContent = (warnings.length? 'Готово с предупреждениями':'Готово') + '. Скопируйте результат в .htaccess.';
    });

    document.getElementById('copyOut').addEventListener('click', ()=>{
      const out = document.getElementById('output');
      out.select();
      document.execCommand('copy');
      document.getElementById('info').textContent = 'Скопировано в буфер обмена.';
    });
  </script>
</body>
</html>
